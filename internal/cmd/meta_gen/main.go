package main

import (
	"encoding/json"
	"io/ioutil"
	"log"
	"os"
	"text/template"

	"github.com/Xuanwo/templateutils"

	"github.com/Xuanwo/storage/types"
)

type metadata struct {
	Name       string                     `json:"name"`
	Capability map[string]bool            `json:"capability"`
	Service    map[string]map[string]bool `json:"service"`
	Storage    map[string]map[string]bool `json:"storage"`

	TypeMap map[string]string `json:"-"`
}

func main() {
	_, err := ioutil.ReadDir(".")
	if err != nil {
		log.Fatalf("read dir failed: %v", err)
	}

	metaPath := "meta.json"
	if _, err := os.Stat(metaPath); err != nil {
		log.Fatalf("stat meta failed: %v", err)
	}

	content, err := ioutil.ReadFile(metaPath)
	if err != nil {
		log.Fatalf("read file failed: %v", err)
	}

	var meta metadata

	err = json.Unmarshal(content, &meta)
	if err != nil {
		log.Fatalf("json unmarshal failed: %v", err)
	}
	meta.TypeMap = types.AvailablePairs

	filePath := "meta.go"
	f, err := os.Create(filePath)
	if err != nil {
		log.Fatal(err)
	}
	err = metaTmpl.Execute(f, meta)
	if err != nil {
		log.Fatal(err)
	}
	err = pairTmpl.Execute(f, meta)
	if err != nil {
		log.Fatal(err)
	}
}

var metaTmpl = template.Must(template.New("").Funcs(templateutils.FuncMap()).Parse(`// Code generated by go generate via internal/cmd/meta_gen; DO NOT EDIT.
package {{ .Name }}

import (
	"github.com/Xuanwo/storage"
	"github.com/Xuanwo/storage/types"
)

{{- if .Service }}
// ServicerType is the servicer type for {{ .Name }}
const ServicerType = types.ServicerType("{{ .Name }}")
{{- end }}

// StoragerType is the storager type for {{ .Name }}
const StoragerType = types.StoragerType("{{ .Name }}")
`))

var pairTmpl = template.Must(template.New("pair").Funcs(templateutils.FuncMap()).Parse(`
{{ $Data := . }}

var notAllowedStorageAction = map[string]struct{}{
{{- range $k, $v := .Capability }}
	"{{$k}}": struct{}{},
{{- end }}
}


var allowedStoragePairs = map[string]map[string]struct{}{
{{- range $k, $v := .Storage }}
	storage.Action{{ $k | camelCase}}: {
{{- range $key, $_ := $v }}
		"{{$key}}": struct{}{},
{{- end }}
	},
{{- end }}
}

var allowedServicePairs = map[string]map[string]struct{}{
{{- range $k, $v := .Service }}
	"{{ $k }}": {
{{- range $key, $_ := $v }}
		"{{$key}}": struct{}{},
{{- end }}
	},
{{- end }}
}

// Capable implements Storager.Capable().
func (c *Client) Capable(action string, pair ...string) bool {
	if _, ok := notAllowedStorageAction[action]; ok {
		return false
	}
	// If no pair input, we only need to check action.
	if len(pair) == 0 {
		return true
	}

	if _, ok := allowedStoragePairs[action]; !ok {
		return false
	}
	for _, v := range pair {
		if _, ok := allowedStoragePairs[action][v]; !ok {
			return false
		}
	}
	return true
}

{{- range $k, $v := .Storage }}
type pairStorage{{ $k | camelCase}} struct {
{{- range $key, $_ := $v }}
	Has{{ $key | camelCase}} bool
	{{ $key | camelCase}}    {{ index $Data.TypeMap $key }}
{{- end }}
}

func parseStoragePair{{ $k | camelCase}}(opts ...*types.Pair) (*pairStorage{{ $k | camelCase}}, error) {
	result := &pairStorage{{ $k | camelCase}}{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedStoragePairs[storage.Action{{ $k | camelCase}}]; !ok {
			continue
		}
		if _, ok := allowedStoragePairs[storage.Action{{ $k | camelCase}}][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}

{{- if $v }}
	var v interface{}
	var ok bool
{{- end }}

{{- range $key, $required := $v }}
	v, ok = values[types.{{ $key | camelCase}}]
{{- if $required }}
	if !ok {
		return nil, types.NewErrPairRequired(types.{{ $key | camelCase}})
	}
{{- end }}
	if ok {
		result.Has{{ $key | camelCase}} = true
		result.{{ $key | camelCase}} = v.({{ index $Data.TypeMap $key }})
	}
{{- end }}
	return result, nil
}
{{- end }}

{{- range $k, $v := .Service }}
type pairService{{ $k | camelCase}} struct {
{{- range $key, $_ := $v }}
	Has{{ $key | camelCase}} bool
	{{ $key | camelCase}}    {{ index $Data.TypeMap $key }}
{{- end }}
}

func parseServicePair{{ $k | camelCase}}(opts ...*types.Pair) (*pairService{{ $k | camelCase}}, error) {
	result := &pairService{{ $k | camelCase}}{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedServicePairs["{{ $k }}"]; !ok {
			continue
		}
		if _, ok := allowedServicePairs["{{ $k }}"][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}

{{- if $v }}
	var v interface{}
	var ok bool
{{- end }}

{{- range $key, $required := $v }}
	v, ok = values[types.{{ $key | camelCase}}]
{{- if $required }}
	if !ok {
		return nil, types.NewErrPairRequired(types.{{ $key | camelCase}})
	}
{{- end }}
	if ok {
		result.Has{{ $key | camelCase}} = true
		result.{{ $key | camelCase}} = v.({{ index $Data.TypeMap $key }})
	}
{{- end }}
	return result, nil
}
{{- end }}
`))
