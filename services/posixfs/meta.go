// Code generated by go generate via internal/cmd/meta_gen; DO NOT EDIT.
package posixfs

import (
	"github.com/Xuanwo/storage"
	"github.com/Xuanwo/storage/types"
)

// CapabilityRead    = true
// CapabilityWrite   = true
// CapabilityFile    = true
// CapabilityStream  = true
// CapabilitySegment = true
const capability = types.Capability(31)

// Capability implements Storager.Capability().
func (c *Client) Capability() types.Capability {
	return capability
}

var allowedPairs = map[string]map[string]struct{}{
	storage.ActionAbortSegment:    {},
	storage.ActionCompleteSegment: {},
	storage.ActionCopy:            {},
	storage.ActionDelete:          {},
	storage.ActionInitSegment:     {},
	storage.ActionListDir:         {},
	storage.ActionMove:            {},
	storage.ActionRead:            {},
	storage.ActionReadSegment:     {},
	storage.ActionStat:            {},
	storage.ActionWriteFile:       {},
	storage.ActionWriteSegment:    {},
	storage.ActionWriteStream:     {},
}

// IsPairAvailable implements Storager.IsPairAvailable().
func (c *Client) IsPairAvailable(action, pair string) bool {
	if _, ok := allowedPairs[action]; !ok {
		return false
	}
	if _, ok := allowedPairs[action][pair]; !ok {
		return false
	}
	return true
}

type pairAbortSegment struct {
}

func parsePairAbortSegment(opts ...*types.Pair) (*pairAbortSegment, error) {
	result := &pairAbortSegment{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedPairs[storage.ActionAbortSegment]; !ok {
			continue
		}
		if _, ok := allowedPairs[storage.ActionAbortSegment][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairCompleteSegment struct {
}

func parsePairCompleteSegment(opts ...*types.Pair) (*pairCompleteSegment, error) {
	result := &pairCompleteSegment{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedPairs[storage.ActionCompleteSegment]; !ok {
			continue
		}
		if _, ok := allowedPairs[storage.ActionCompleteSegment][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairCopy struct {
}

func parsePairCopy(opts ...*types.Pair) (*pairCopy, error) {
	result := &pairCopy{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedPairs[storage.ActionCopy]; !ok {
			continue
		}
		if _, ok := allowedPairs[storage.ActionCopy][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairDelete struct {
}

func parsePairDelete(opts ...*types.Pair) (*pairDelete, error) {
	result := &pairDelete{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedPairs[storage.ActionDelete]; !ok {
			continue
		}
		if _, ok := allowedPairs[storage.ActionDelete][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairInitSegment struct {
}

func parsePairInitSegment(opts ...*types.Pair) (*pairInitSegment, error) {
	result := &pairInitSegment{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedPairs[storage.ActionInitSegment]; !ok {
			continue
		}
		if _, ok := allowedPairs[storage.ActionInitSegment][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairListDir struct {
}

func parsePairListDir(opts ...*types.Pair) (*pairListDir, error) {
	result := &pairListDir{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedPairs[storage.ActionListDir]; !ok {
			continue
		}
		if _, ok := allowedPairs[storage.ActionListDir][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairMove struct {
}

func parsePairMove(opts ...*types.Pair) (*pairMove, error) {
	result := &pairMove{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedPairs[storage.ActionMove]; !ok {
			continue
		}
		if _, ok := allowedPairs[storage.ActionMove][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairRead struct {
}

func parsePairRead(opts ...*types.Pair) (*pairRead, error) {
	result := &pairRead{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedPairs[storage.ActionRead]; !ok {
			continue
		}
		if _, ok := allowedPairs[storage.ActionRead][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairReadSegment struct {
}

func parsePairReadSegment(opts ...*types.Pair) (*pairReadSegment, error) {
	result := &pairReadSegment{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedPairs[storage.ActionReadSegment]; !ok {
			continue
		}
		if _, ok := allowedPairs[storage.ActionReadSegment][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairStat struct {
}

func parsePairStat(opts ...*types.Pair) (*pairStat, error) {
	result := &pairStat{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedPairs[storage.ActionStat]; !ok {
			continue
		}
		if _, ok := allowedPairs[storage.ActionStat][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairWriteFile struct {
}

func parsePairWriteFile(opts ...*types.Pair) (*pairWriteFile, error) {
	result := &pairWriteFile{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedPairs[storage.ActionWriteFile]; !ok {
			continue
		}
		if _, ok := allowedPairs[storage.ActionWriteFile][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairWriteSegment struct {
}

func parsePairWriteSegment(opts ...*types.Pair) (*pairWriteSegment, error) {
	result := &pairWriteSegment{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedPairs[storage.ActionWriteSegment]; !ok {
			continue
		}
		if _, ok := allowedPairs[storage.ActionWriteSegment][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairWriteStream struct {
}

func parsePairWriteStream(opts ...*types.Pair) (*pairWriteStream, error) {
	result := &pairWriteStream{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedPairs[storage.ActionWriteStream]; !ok {
			continue
		}
		if _, ok := allowedPairs[storage.ActionWriteStream][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}
