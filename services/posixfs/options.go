// Code generated by go generate via internal/cmd/meta_gen; DO NOT EDIT.
package posixfs

import (
	"github.com/Xuanwo/storage"
	"github.com/Xuanwo/storage/types"
)

var allowdOptions = map[string]map[string]struct{}{
	storage.ActionAbortSegment:    {},
	storage.ActionCompleteSegment: {},
	storage.ActionCopy:            {},
	storage.ActionDelete:          {},
	storage.ActionInitSegment:     {},
	storage.ActionListDir:         {},
	storage.ActionMove:            {},
	storage.ActionReadFile:        {},
	storage.ActionReadSegment:     {},
	storage.ActionReadStream:      {},
	storage.ActionStat:            {},
	storage.ActionWriteFile:       {},
	storage.ActionWriteSegment:    {},
	storage.ActionWriteStream:     {},
}

// IsOptionAvailable implements Storager.IsOptionAvailable().
func (c *Client) IsOptionAvailable(action, option string) bool {
	if _, ok := allowdOptions[action]; !ok {
		return false
	}
	if _, ok := allowdOptions[action][option]; !ok {
		return false
	}
	return true
}

type optionAbortSegment struct {
}

func parseOptionAbortSegment(opts ...types.Option) *optionAbortSegment {
	result := &optionAbortSegment{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowdOptions[storage.ActionAbortSegment]; !ok {
			continue
		}
		if _, ok := allowdOptions[storage.ActionAbortSegment][v.Key]; !ok {
			continue
		}
		values[v.Key] = v
	}
	return result
}

type optionCompleteSegment struct {
}

func parseOptionCompleteSegment(opts ...types.Option) *optionCompleteSegment {
	result := &optionCompleteSegment{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowdOptions[storage.ActionCompleteSegment]; !ok {
			continue
		}
		if _, ok := allowdOptions[storage.ActionCompleteSegment][v.Key]; !ok {
			continue
		}
		values[v.Key] = v
	}
	return result
}

type optionCopy struct {
}

func parseOptionCopy(opts ...types.Option) *optionCopy {
	result := &optionCopy{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowdOptions[storage.ActionCopy]; !ok {
			continue
		}
		if _, ok := allowdOptions[storage.ActionCopy][v.Key]; !ok {
			continue
		}
		values[v.Key] = v
	}
	return result
}

type optionDelete struct {
}

func parseOptionDelete(opts ...types.Option) *optionDelete {
	result := &optionDelete{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowdOptions[storage.ActionDelete]; !ok {
			continue
		}
		if _, ok := allowdOptions[storage.ActionDelete][v.Key]; !ok {
			continue
		}
		values[v.Key] = v
	}
	return result
}

type optionInitSegment struct {
}

func parseOptionInitSegment(opts ...types.Option) *optionInitSegment {
	result := &optionInitSegment{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowdOptions[storage.ActionInitSegment]; !ok {
			continue
		}
		if _, ok := allowdOptions[storage.ActionInitSegment][v.Key]; !ok {
			continue
		}
		values[v.Key] = v
	}
	return result
}

type optionListDir struct {
}

func parseOptionListDir(opts ...types.Option) *optionListDir {
	result := &optionListDir{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowdOptions[storage.ActionListDir]; !ok {
			continue
		}
		if _, ok := allowdOptions[storage.ActionListDir][v.Key]; !ok {
			continue
		}
		values[v.Key] = v
	}
	return result
}

type optionMove struct {
}

func parseOptionMove(opts ...types.Option) *optionMove {
	result := &optionMove{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowdOptions[storage.ActionMove]; !ok {
			continue
		}
		if _, ok := allowdOptions[storage.ActionMove][v.Key]; !ok {
			continue
		}
		values[v.Key] = v
	}
	return result
}

type optionReadFile struct {
}

func parseOptionReadFile(opts ...types.Option) *optionReadFile {
	result := &optionReadFile{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowdOptions[storage.ActionReadFile]; !ok {
			continue
		}
		if _, ok := allowdOptions[storage.ActionReadFile][v.Key]; !ok {
			continue
		}
		values[v.Key] = v
	}
	return result
}

type optionReadSegment struct {
}

func parseOptionReadSegment(opts ...types.Option) *optionReadSegment {
	result := &optionReadSegment{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowdOptions[storage.ActionReadSegment]; !ok {
			continue
		}
		if _, ok := allowdOptions[storage.ActionReadSegment][v.Key]; !ok {
			continue
		}
		values[v.Key] = v
	}
	return result
}

type optionReadStream struct {
}

func parseOptionReadStream(opts ...types.Option) *optionReadStream {
	result := &optionReadStream{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowdOptions[storage.ActionReadStream]; !ok {
			continue
		}
		if _, ok := allowdOptions[storage.ActionReadStream][v.Key]; !ok {
			continue
		}
		values[v.Key] = v
	}
	return result
}

type optionStat struct {
}

func parseOptionStat(opts ...types.Option) *optionStat {
	result := &optionStat{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowdOptions[storage.ActionStat]; !ok {
			continue
		}
		if _, ok := allowdOptions[storage.ActionStat][v.Key]; !ok {
			continue
		}
		values[v.Key] = v
	}
	return result
}

type optionWriteFile struct {
}

func parseOptionWriteFile(opts ...types.Option) *optionWriteFile {
	result := &optionWriteFile{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowdOptions[storage.ActionWriteFile]; !ok {
			continue
		}
		if _, ok := allowdOptions[storage.ActionWriteFile][v.Key]; !ok {
			continue
		}
		values[v.Key] = v
	}
	return result
}

type optionWriteSegment struct {
}

func parseOptionWriteSegment(opts ...types.Option) *optionWriteSegment {
	result := &optionWriteSegment{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowdOptions[storage.ActionWriteSegment]; !ok {
			continue
		}
		if _, ok := allowdOptions[storage.ActionWriteSegment][v.Key]; !ok {
			continue
		}
		values[v.Key] = v
	}
	return result
}

type optionWriteStream struct {
}

func parseOptionWriteStream(opts ...types.Option) *optionWriteStream {
	result := &optionWriteStream{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowdOptions[storage.ActionWriteStream]; !ok {
			continue
		}
		if _, ok := allowdOptions[storage.ActionWriteStream][v.Key]; !ok {
			continue
		}
		values[v.Key] = v
	}
	return result
}
