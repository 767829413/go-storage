// Code generated by go generate via internal/cmd/meta_gen; DO NOT EDIT.
package qingstor

import (
	"github.com/Xuanwo/storage"
	"github.com/Xuanwo/storage/types"
)

var allowdOptions = map[string]map[string]struct{}{
	storage.ActionAbortSegment:    {},
	storage.ActionCompleteSegment: {},
	storage.ActionCopy:            {},
	storage.ActionCreateDir: {
		"location": struct{}{},
	},
	storage.ActionDelete:      {},
	storage.ActionInitSegment: {},
	storage.ActionListDir:     {},
	storage.ActionMove:        {},
	storage.ActionReadFile:    {},
	storage.ActionReadSegment: {},
	storage.ActionReadStream:  {},
	storage.ActionStat:        {},
	storage.ActionWriteFile: {
		"checksum":      struct{}{},
		"storage_class": struct{}{},
	},
	storage.ActionWriteSegment: {},
	storage.ActionWriteStream:  {},
}

// IsOptionAvailable implements Storager.IsOptionAvailable().
func (c *Client) IsOptionAvailable(action, option string) bool {
	if _, ok := allowdOptions[action]; !ok {
		return false
	}
	if _, ok := allowdOptions[action][option]; !ok {
		return false
	}
	return true
}

type optionAbortSegment struct {
}

func parseOptionAbortSegment(opts ...*types.Option) *optionAbortSegment {
	result := &optionAbortSegment{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowdOptions[storage.ActionAbortSegment]; !ok {
			continue
		}
		if _, ok := allowdOptions[storage.ActionAbortSegment][v.Key]; !ok {
			continue
		}
		values[v.Key] = v
	}
	return result
}

type optionCompleteSegment struct {
}

func parseOptionCompleteSegment(opts ...*types.Option) *optionCompleteSegment {
	result := &optionCompleteSegment{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowdOptions[storage.ActionCompleteSegment]; !ok {
			continue
		}
		if _, ok := allowdOptions[storage.ActionCompleteSegment][v.Key]; !ok {
			continue
		}
		values[v.Key] = v
	}
	return result
}

type optionCopy struct {
}

func parseOptionCopy(opts ...*types.Option) *optionCopy {
	result := &optionCopy{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowdOptions[storage.ActionCopy]; !ok {
			continue
		}
		if _, ok := allowdOptions[storage.ActionCopy][v.Key]; !ok {
			continue
		}
		values[v.Key] = v
	}
	return result
}

type optionCreateDir struct {
	HasLocation bool
	Location    string
}

func parseOptionCreateDir(opts ...*types.Option) *optionCreateDir {
	result := &optionCreateDir{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowdOptions[storage.ActionCreateDir]; !ok {
			continue
		}
		if _, ok := allowdOptions[storage.ActionCreateDir][v.Key]; !ok {
			continue
		}
		values[v.Key] = v
	}
	if v, ok := values["location"]; !ok {
		result.HasLocation = true
		result.Location = v.(string)
	}
	return result
}

type optionDelete struct {
}

func parseOptionDelete(opts ...*types.Option) *optionDelete {
	result := &optionDelete{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowdOptions[storage.ActionDelete]; !ok {
			continue
		}
		if _, ok := allowdOptions[storage.ActionDelete][v.Key]; !ok {
			continue
		}
		values[v.Key] = v
	}
	return result
}

type optionInitSegment struct {
}

func parseOptionInitSegment(opts ...*types.Option) *optionInitSegment {
	result := &optionInitSegment{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowdOptions[storage.ActionInitSegment]; !ok {
			continue
		}
		if _, ok := allowdOptions[storage.ActionInitSegment][v.Key]; !ok {
			continue
		}
		values[v.Key] = v
	}
	return result
}

type optionListDir struct {
}

func parseOptionListDir(opts ...*types.Option) *optionListDir {
	result := &optionListDir{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowdOptions[storage.ActionListDir]; !ok {
			continue
		}
		if _, ok := allowdOptions[storage.ActionListDir][v.Key]; !ok {
			continue
		}
		values[v.Key] = v
	}
	return result
}

type optionMove struct {
}

func parseOptionMove(opts ...*types.Option) *optionMove {
	result := &optionMove{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowdOptions[storage.ActionMove]; !ok {
			continue
		}
		if _, ok := allowdOptions[storage.ActionMove][v.Key]; !ok {
			continue
		}
		values[v.Key] = v
	}
	return result
}

type optionReadFile struct {
}

func parseOptionReadFile(opts ...*types.Option) *optionReadFile {
	result := &optionReadFile{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowdOptions[storage.ActionReadFile]; !ok {
			continue
		}
		if _, ok := allowdOptions[storage.ActionReadFile][v.Key]; !ok {
			continue
		}
		values[v.Key] = v
	}
	return result
}

type optionReadSegment struct {
}

func parseOptionReadSegment(opts ...*types.Option) *optionReadSegment {
	result := &optionReadSegment{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowdOptions[storage.ActionReadSegment]; !ok {
			continue
		}
		if _, ok := allowdOptions[storage.ActionReadSegment][v.Key]; !ok {
			continue
		}
		values[v.Key] = v
	}
	return result
}

type optionReadStream struct {
}

func parseOptionReadStream(opts ...*types.Option) *optionReadStream {
	result := &optionReadStream{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowdOptions[storage.ActionReadStream]; !ok {
			continue
		}
		if _, ok := allowdOptions[storage.ActionReadStream][v.Key]; !ok {
			continue
		}
		values[v.Key] = v
	}
	return result
}

type optionStat struct {
}

func parseOptionStat(opts ...*types.Option) *optionStat {
	result := &optionStat{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowdOptions[storage.ActionStat]; !ok {
			continue
		}
		if _, ok := allowdOptions[storage.ActionStat][v.Key]; !ok {
			continue
		}
		values[v.Key] = v
	}
	return result
}

type optionWriteFile struct {
	HasChecksum     bool
	Checksum        string
	HasStorageClass bool
	StorageClass    string
}

func parseOptionWriteFile(opts ...*types.Option) *optionWriteFile {
	result := &optionWriteFile{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowdOptions[storage.ActionWriteFile]; !ok {
			continue
		}
		if _, ok := allowdOptions[storage.ActionWriteFile][v.Key]; !ok {
			continue
		}
		values[v.Key] = v
	}
	if v, ok := values["checksum"]; !ok {
		result.HasChecksum = true
		result.Checksum = v.(string)
	}
	if v, ok := values["storage_class"]; !ok {
		result.HasStorageClass = true
		result.StorageClass = v.(string)
	}
	return result
}

type optionWriteSegment struct {
}

func parseOptionWriteSegment(opts ...*types.Option) *optionWriteSegment {
	result := &optionWriteSegment{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowdOptions[storage.ActionWriteSegment]; !ok {
			continue
		}
		if _, ok := allowdOptions[storage.ActionWriteSegment][v.Key]; !ok {
			continue
		}
		values[v.Key] = v
	}
	return result
}

type optionWriteStream struct {
}

func parseOptionWriteStream(opts ...*types.Option) *optionWriteStream {
	result := &optionWriteStream{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowdOptions[storage.ActionWriteStream]; !ok {
			continue
		}
		if _, ok := allowdOptions[storage.ActionWriteStream][v.Key]; !ok {
			continue
		}
		values[v.Key] = v
	}
	return result
}
