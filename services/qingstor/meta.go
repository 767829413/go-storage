// Code generated by go generate via internal/cmd/meta_gen; DO NOT EDIT.
package qingstor

import (
	"github.com/Xuanwo/storage"
	"github.com/Xuanwo/storage/types"
)

// CapabilityRead    = true
// CapabilityWrite   = true
// CapabilityFile    = true
// CapabilityStream  = false
// CapabilitySegment = true
const capability = types.Capability(23)

// Capability implements Storager.Capability().
func (c *Client) Capability() types.Capability {
	return capability
}

var allowedStoragePairs = map[string]map[string]struct{}{
	storage.ActionAbortSegment:    {},
	storage.ActionCompleteSegment: {},
	storage.ActionCopy:            {},
	storage.ActionCreateDir: {
		"location": struct{}{},
	},
	storage.ActionDelete:      {},
	storage.ActionInitSegment: {},
	storage.ActionListDir: {
		"delimiter": struct{}{},
	},
	storage.ActionMove: {},
	storage.ActionReach: {
		"expire": struct{}{},
	},
	storage.ActionRead:        {},
	storage.ActionReadSegment: {},
	storage.ActionStat:        {},
	storage.ActionWriteFile: {
		"checksum":      struct{}{},
		"storage_class": struct{}{},
	},
	storage.ActionWriteSegment: {},
	storage.ActionWriteStream:  {},
}

var allowedServicePairs = map[string]map[string]struct{}{
	"create": {
		"location": struct{}{},
	},
	"get": {
		"location": struct{}{},
	},
	"init": {
		"access_key": struct{}{},
		"host":       struct{}{},
		"port":       struct{}{},
		"protocol":   struct{}{},
		"secret_key": struct{}{},
	},
}

// IsPairAvailable implements Storager.IsPairAvailable().
func (c *Client) IsPairAvailable(action, pair string) bool {
	if _, ok := allowedStoragePairs[action]; !ok {
		return false
	}
	if _, ok := allowedStoragePairs[action][pair]; !ok {
		return false
	}
	return true
}

type pairStorageAbortSegment struct {
}

func parseStoragePairAbortSegment(opts ...*types.Pair) (*pairStorageAbortSegment, error) {
	result := &pairStorageAbortSegment{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedStoragePairs[storage.ActionAbortSegment]; !ok {
			continue
		}
		if _, ok := allowedStoragePairs[storage.ActionAbortSegment][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairStorageCompleteSegment struct {
}

func parseStoragePairCompleteSegment(opts ...*types.Pair) (*pairStorageCompleteSegment, error) {
	result := &pairStorageCompleteSegment{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedStoragePairs[storage.ActionCompleteSegment]; !ok {
			continue
		}
		if _, ok := allowedStoragePairs[storage.ActionCompleteSegment][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairStorageCopy struct {
}

func parseStoragePairCopy(opts ...*types.Pair) (*pairStorageCopy, error) {
	result := &pairStorageCopy{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedStoragePairs[storage.ActionCopy]; !ok {
			continue
		}
		if _, ok := allowedStoragePairs[storage.ActionCopy][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairStorageCreateDir struct {
	HasLocation bool
	Location    string
}

func parseStoragePairCreateDir(opts ...*types.Pair) (*pairStorageCreateDir, error) {
	result := &pairStorageCreateDir{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedStoragePairs[storage.ActionCreateDir]; !ok {
			continue
		}
		if _, ok := allowedStoragePairs[storage.ActionCreateDir][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	var v interface{}
	var ok bool
	v, ok = values[types.Location]
	if !ok {
		return nil, types.NewErrPairRequired(types.Location)
	}
	if ok {
		result.HasLocation = true
		result.Location = v.(string)
	}
	return result, nil
}

type pairStorageDelete struct {
}

func parseStoragePairDelete(opts ...*types.Pair) (*pairStorageDelete, error) {
	result := &pairStorageDelete{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedStoragePairs[storage.ActionDelete]; !ok {
			continue
		}
		if _, ok := allowedStoragePairs[storage.ActionDelete][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairStorageInitSegment struct {
}

func parseStoragePairInitSegment(opts ...*types.Pair) (*pairStorageInitSegment, error) {
	result := &pairStorageInitSegment{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedStoragePairs[storage.ActionInitSegment]; !ok {
			continue
		}
		if _, ok := allowedStoragePairs[storage.ActionInitSegment][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairStorageListDir struct {
	HasDelimiter bool
	Delimiter    string
}

func parseStoragePairListDir(opts ...*types.Pair) (*pairStorageListDir, error) {
	result := &pairStorageListDir{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedStoragePairs[storage.ActionListDir]; !ok {
			continue
		}
		if _, ok := allowedStoragePairs[storage.ActionListDir][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	var v interface{}
	var ok bool
	v, ok = values[types.Delimiter]
	if ok {
		result.HasDelimiter = true
		result.Delimiter = v.(string)
	}
	return result, nil
}

type pairStorageMove struct {
}

func parseStoragePairMove(opts ...*types.Pair) (*pairStorageMove, error) {
	result := &pairStorageMove{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedStoragePairs[storage.ActionMove]; !ok {
			continue
		}
		if _, ok := allowedStoragePairs[storage.ActionMove][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairStorageReach struct {
	HasExpire bool
	Expire    int
}

func parseStoragePairReach(opts ...*types.Pair) (*pairStorageReach, error) {
	result := &pairStorageReach{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedStoragePairs[storage.ActionReach]; !ok {
			continue
		}
		if _, ok := allowedStoragePairs[storage.ActionReach][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	var v interface{}
	var ok bool
	v, ok = values[types.Expire]
	if !ok {
		return nil, types.NewErrPairRequired(types.Expire)
	}
	if ok {
		result.HasExpire = true
		result.Expire = v.(int)
	}
	return result, nil
}

type pairStorageRead struct {
}

func parseStoragePairRead(opts ...*types.Pair) (*pairStorageRead, error) {
	result := &pairStorageRead{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedStoragePairs[storage.ActionRead]; !ok {
			continue
		}
		if _, ok := allowedStoragePairs[storage.ActionRead][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairStorageReadSegment struct {
}

func parseStoragePairReadSegment(opts ...*types.Pair) (*pairStorageReadSegment, error) {
	result := &pairStorageReadSegment{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedStoragePairs[storage.ActionReadSegment]; !ok {
			continue
		}
		if _, ok := allowedStoragePairs[storage.ActionReadSegment][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairStorageStat struct {
}

func parseStoragePairStat(opts ...*types.Pair) (*pairStorageStat, error) {
	result := &pairStorageStat{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedStoragePairs[storage.ActionStat]; !ok {
			continue
		}
		if _, ok := allowedStoragePairs[storage.ActionStat][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairStorageWriteFile struct {
	HasChecksum     bool
	Checksum        string
	HasStorageClass bool
	StorageClass    string
}

func parseStoragePairWriteFile(opts ...*types.Pair) (*pairStorageWriteFile, error) {
	result := &pairStorageWriteFile{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedStoragePairs[storage.ActionWriteFile]; !ok {
			continue
		}
		if _, ok := allowedStoragePairs[storage.ActionWriteFile][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	var v interface{}
	var ok bool
	v, ok = values[types.Checksum]
	if ok {
		result.HasChecksum = true
		result.Checksum = v.(string)
	}
	v, ok = values[types.StorageClass]
	if ok {
		result.HasStorageClass = true
		result.StorageClass = v.(string)
	}
	return result, nil
}

type pairStorageWriteSegment struct {
}

func parseStoragePairWriteSegment(opts ...*types.Pair) (*pairStorageWriteSegment, error) {
	result := &pairStorageWriteSegment{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedStoragePairs[storage.ActionWriteSegment]; !ok {
			continue
		}
		if _, ok := allowedStoragePairs[storage.ActionWriteSegment][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairStorageWriteStream struct {
}

func parseStoragePairWriteStream(opts ...*types.Pair) (*pairStorageWriteStream, error) {
	result := &pairStorageWriteStream{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedStoragePairs[storage.ActionWriteStream]; !ok {
			continue
		}
		if _, ok := allowedStoragePairs[storage.ActionWriteStream][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairServiceCreate struct {
	HasLocation bool
	Location    string
}

func parseServicePairCreate(opts ...*types.Pair) (*pairServiceCreate, error) {
	result := &pairServiceCreate{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedServicePairs["create"]; !ok {
			continue
		}
		if _, ok := allowedServicePairs["create"][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	var v interface{}
	var ok bool
	v, ok = values[types.Location]
	if !ok {
		return nil, types.NewErrPairRequired(types.Location)
	}
	if ok {
		result.HasLocation = true
		result.Location = v.(string)
	}
	return result, nil
}

type pairServiceGet struct {
	HasLocation bool
	Location    string
}

func parseServicePairGet(opts ...*types.Pair) (*pairServiceGet, error) {
	result := &pairServiceGet{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedServicePairs["get"]; !ok {
			continue
		}
		if _, ok := allowedServicePairs["get"][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	var v interface{}
	var ok bool
	v, ok = values[types.Location]
	if ok {
		result.HasLocation = true
		result.Location = v.(string)
	}
	return result, nil
}

type pairServiceInit struct {
	HasAccessKey bool
	AccessKey    string
	HasHost      bool
	Host         string
	HasPort      bool
	Port         int
	HasProtocol  bool
	Protocol     string
	HasSecretKey bool
	SecretKey    string
}

func parseServicePairInit(opts ...*types.Pair) (*pairServiceInit, error) {
	result := &pairServiceInit{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedServicePairs["init"]; !ok {
			continue
		}
		if _, ok := allowedServicePairs["init"][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	var v interface{}
	var ok bool
	v, ok = values[types.AccessKey]
	if !ok {
		return nil, types.NewErrPairRequired(types.AccessKey)
	}
	if ok {
		result.HasAccessKey = true
		result.AccessKey = v.(string)
	}
	v, ok = values[types.Host]
	if ok {
		result.HasHost = true
		result.Host = v.(string)
	}
	v, ok = values[types.Port]
	if ok {
		result.HasPort = true
		result.Port = v.(int)
	}
	v, ok = values[types.Protocol]
	if ok {
		result.HasProtocol = true
		result.Protocol = v.(string)
	}
	v, ok = values[types.SecretKey]
	if !ok {
		return nil, types.NewErrPairRequired(types.SecretKey)
	}
	if ok {
		result.HasSecretKey = true
		result.SecretKey = v.(string)
	}
	return result, nil
}
