// Code generated by go generate via internal/cmd/meta_gen; DO NOT EDIT.
package qingstor

import (
	"github.com/Xuanwo/storage"
	"github.com/Xuanwo/storage/types"
)

// CapabilityRead    = true
// CapabilityWrite   = true
// CapabilityFile    = true
// CapabilityStream  = false
// CapabilitySegment = true
const capability = types.Capability(23)

// Capability implements Storager.Capability().
func (c *Client) Capability() types.Capability {
	return capability
}

var allowedPairs = map[string]map[string]struct{}{
	storage.ActionAbortSegment:    {},
	storage.ActionCompleteSegment: {},
	storage.ActionCopy:            {},
	storage.ActionCreateDir: {
		"location": struct{}{},
	},
	storage.ActionDelete:      {},
	storage.ActionInitSegment: {},
	storage.ActionListDir: {
		"delimiter": struct{}{},
	},
	storage.ActionMove: {},
	storage.ActionReach: {
		"expire": struct{}{},
	},
	storage.ActionRead:        {},
	storage.ActionReadSegment: {},
	storage.ActionStat:        {},
	storage.ActionWriteFile: {
		"checksum":      struct{}{},
		"storage_class": struct{}{},
	},
	storage.ActionWriteSegment: {},
	storage.ActionWriteStream:  {},
}

// IsPairAvailable implements Storager.IsPairAvailable().
func (c *Client) IsPairAvailable(action, pair string) bool {
	if _, ok := allowedPairs[action]; !ok {
		return false
	}
	if _, ok := allowedPairs[action][pair]; !ok {
		return false
	}
	return true
}

type pairAbortSegment struct {
}

func parsePairAbortSegment(opts ...*types.Pair) (*pairAbortSegment, error) {
	result := &pairAbortSegment{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedPairs[storage.ActionAbortSegment]; !ok {
			continue
		}
		if _, ok := allowedPairs[storage.ActionAbortSegment][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairCompleteSegment struct {
}

func parsePairCompleteSegment(opts ...*types.Pair) (*pairCompleteSegment, error) {
	result := &pairCompleteSegment{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedPairs[storage.ActionCompleteSegment]; !ok {
			continue
		}
		if _, ok := allowedPairs[storage.ActionCompleteSegment][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairCopy struct {
}

func parsePairCopy(opts ...*types.Pair) (*pairCopy, error) {
	result := &pairCopy{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedPairs[storage.ActionCopy]; !ok {
			continue
		}
		if _, ok := allowedPairs[storage.ActionCopy][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairCreateDir struct {
	HasLocation bool
	Location    string
}

func parsePairCreateDir(opts ...*types.Pair) (*pairCreateDir, error) {
	result := &pairCreateDir{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedPairs[storage.ActionCreateDir]; !ok {
			continue
		}
		if _, ok := allowedPairs[storage.ActionCreateDir][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	var v interface{}
	var ok bool
	v, ok = values[types.Location]
	if !ok {
		return nil, types.NewErrPairRequired(types.Location)
	}
	if ok {
		result.HasLocation = true
		result.Location = v.(string)
	}
	return result, nil
}

type pairDelete struct {
}

func parsePairDelete(opts ...*types.Pair) (*pairDelete, error) {
	result := &pairDelete{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedPairs[storage.ActionDelete]; !ok {
			continue
		}
		if _, ok := allowedPairs[storage.ActionDelete][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairInitSegment struct {
}

func parsePairInitSegment(opts ...*types.Pair) (*pairInitSegment, error) {
	result := &pairInitSegment{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedPairs[storage.ActionInitSegment]; !ok {
			continue
		}
		if _, ok := allowedPairs[storage.ActionInitSegment][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairListDir struct {
	HasDelimiter bool
	Delimiter    string
}

func parsePairListDir(opts ...*types.Pair) (*pairListDir, error) {
	result := &pairListDir{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedPairs[storage.ActionListDir]; !ok {
			continue
		}
		if _, ok := allowedPairs[storage.ActionListDir][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	var v interface{}
	var ok bool
	v, ok = values[types.Delimiter]
	if ok {
		result.HasDelimiter = true
		result.Delimiter = v.(string)
	}
	return result, nil
}

type pairMove struct {
}

func parsePairMove(opts ...*types.Pair) (*pairMove, error) {
	result := &pairMove{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedPairs[storage.ActionMove]; !ok {
			continue
		}
		if _, ok := allowedPairs[storage.ActionMove][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairReach struct {
	HasExpire bool
	Expire    int
}

func parsePairReach(opts ...*types.Pair) (*pairReach, error) {
	result := &pairReach{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedPairs[storage.ActionReach]; !ok {
			continue
		}
		if _, ok := allowedPairs[storage.ActionReach][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	var v interface{}
	var ok bool
	v, ok = values[types.Expire]
	if !ok {
		return nil, types.NewErrPairRequired(types.Expire)
	}
	if ok {
		result.HasExpire = true
		result.Expire = v.(int)
	}
	return result, nil
}

type pairRead struct {
}

func parsePairRead(opts ...*types.Pair) (*pairRead, error) {
	result := &pairRead{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedPairs[storage.ActionRead]; !ok {
			continue
		}
		if _, ok := allowedPairs[storage.ActionRead][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairReadSegment struct {
}

func parsePairReadSegment(opts ...*types.Pair) (*pairReadSegment, error) {
	result := &pairReadSegment{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedPairs[storage.ActionReadSegment]; !ok {
			continue
		}
		if _, ok := allowedPairs[storage.ActionReadSegment][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairStat struct {
}

func parsePairStat(opts ...*types.Pair) (*pairStat, error) {
	result := &pairStat{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedPairs[storage.ActionStat]; !ok {
			continue
		}
		if _, ok := allowedPairs[storage.ActionStat][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairWriteFile struct {
	HasChecksum     bool
	Checksum        string
	HasStorageClass bool
	StorageClass    string
}

func parsePairWriteFile(opts ...*types.Pair) (*pairWriteFile, error) {
	result := &pairWriteFile{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedPairs[storage.ActionWriteFile]; !ok {
			continue
		}
		if _, ok := allowedPairs[storage.ActionWriteFile][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	var v interface{}
	var ok bool
	v, ok = values[types.Checksum]
	if ok {
		result.HasChecksum = true
		result.Checksum = v.(string)
	}
	v, ok = values[types.StorageClass]
	if ok {
		result.HasStorageClass = true
		result.StorageClass = v.(string)
	}
	return result, nil
}

type pairWriteSegment struct {
}

func parsePairWriteSegment(opts ...*types.Pair) (*pairWriteSegment, error) {
	result := &pairWriteSegment{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedPairs[storage.ActionWriteSegment]; !ok {
			continue
		}
		if _, ok := allowedPairs[storage.ActionWriteSegment][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}

type pairWriteStream struct {
}

func parsePairWriteStream(opts ...*types.Pair) (*pairWriteStream, error) {
	result := &pairWriteStream{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedPairs[storage.ActionWriteStream]; !ok {
			continue
		}
		if _, ok := allowedPairs[storage.ActionWriteStream][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	return result, nil
}
